"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/getAddressForFid.ts
var import_viem = require("viem");
var import_chains = require("viem/chains");

// src/getUserDataForFid.ts
var import_core = require("@farcaster/core");
async function getUserDataForFid({
  fid,
  options = {}
}) {
  const {
    hubHttpUrl = "https://api.neynar.com:2281",
    hubRequestOptions = {
      headers: {
        api_key: "NEYNAR_FRAMES_JS"
      }
    }
  } = options;
  const userDataResponse = await fetch(
    `${hubHttpUrl}/v1/userDataByFid?fid=${fid}`,
    hubRequestOptions
  );
  const { messages } = await userDataResponse.json();
  if (messages && messages.length > 0) {
    const valuesByType = messages.reduce((acc, messageJson) => {
      const message = import_core.Message.fromJSON(messageJson);
      if (message.data?.type !== import_core.MessageType.USER_DATA_ADD) {
        return;
      }
      const timestamp = message.data.timestamp;
      const { type, value } = message.data.userDataBody;
      if (!acc[type]) {
        acc[type] = { value, timestamp };
      } else if (message.data.timestamp > acc[type].timestamp) {
        acc[type] = { value, timestamp };
      }
      return acc;
    }, {});
    return {
      profileImage: valuesByType[import_core.UserDataType.PFP]?.value,
      displayName: valuesByType[import_core.UserDataType.DISPLAY]?.value,
      username: valuesByType[import_core.UserDataType.USERNAME]?.value,
      bio: valuesByType[import_core.UserDataType.BIO]?.value
    };
  } else {
    return null;
  }
}

// src/validateFrame.ts
var cheerio = __toESM(require("cheerio"));

// src/utils.ts
var import_core2 = require("@farcaster/core");

// src/validateFrameMessage.ts
var import_core3 = require("@farcaster/core");

// src/getFrameMessage.ts
var import_core4 = require("@farcaster/core");

// src/getUserDataForFid.test.ts
describe("getUserDataForFid", () => {
  it("should get latest user data for fid", async () => {
    const fid = 1214;
    const userData = await getUserDataForFid({ fid });
    expect(userData).not.toBe(null);
  });
  it("should return null for invalid fid", async () => {
    const fid = 1e12;
    const userData = await getUserDataForFid({ fid });
    expect(userData).toBe(null);
  });
});
