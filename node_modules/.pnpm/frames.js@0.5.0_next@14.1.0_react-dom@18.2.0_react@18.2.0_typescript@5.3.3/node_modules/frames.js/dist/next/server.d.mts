import { FrameActionMessage } from '@farcaster/core';
import { NextRequest, NextResponse } from 'next/server';
import React from 'react';
import { FrameActionPayload, HubHttpUrlOptions, ImageAspectRatio } from '../types.mjs';
import { GetFrameMessageOptions, FrameMessageReturnType } from '../getFrameMessage.mjs';
import { FrameState, NextServerPageProps, PreviousFrame, HeadersList, FrameReducer, Dispatch, RedirectHandler, FrameButtonProvidedProps } from './types.mjs';
export { FrameButtonAutomatedProps, FrameButtonLinkProvidedProps, FrameButtonMintProvidedProps, FrameButtonPostProvidedProps, FrameButtonPostRedirectProvidedProps, RedirectMap } from './types.mjs';
import { SatoriOptions } from 'satori';

/** The valid children of a <FrameContainer> */
type FrameElementType = typeof FrameButton | typeof FrameImage | typeof FrameInput;
/** validates a frame action message payload signature, @returns message, throws an Error on failure */
declare function validateActionSignature(frameActionPayload: FrameActionPayload | null, options?: HubHttpUrlOptions): Promise<FrameActionMessage | null>;
/** Convenience wrapper around `framesjs.getFrameMessage` that accepts a null for payload body.
 * Returns a `FrameActionData` object from the message trusted data. (e.g. button index, input text). The `fetchHubContext` option (default: true) determines whether to validate and fetch other metadata from hubs.
 * If `isValid` is false, the message should not be trusted.
 */
declare function getFrameMessage<T extends GetFrameMessageOptions>(frameActionPayload: FrameActionPayload | null, options?: T): Promise<FrameMessageReturnType<T> | null>;
/** deserializes a `PreviousFrame` from url searchParams, fetching headers automatically from nextjs, @returns PreviousFrame */
declare function getPreviousFrame<T extends FrameState = FrameState>(searchParams: NextServerPageProps["searchParams"]): PreviousFrame<T>;
/** @returns PreviousFrame by combining headers and previousFrames from params */
declare function createPreviousFrame<T extends FrameState = FrameState>(previousFrameFromParams: Pick<PreviousFrame<T>, "postBody" | "prevState" | "pathname" | "prevRedirects">, headers: HeadersList): PreviousFrame<T>;
/** deserializes data stored in the url search params and @returns a Partial PreviousFrame object  */
declare function parseFrameParams<T extends FrameState = FrameState>(searchParams: NextServerPageProps["searchParams"]): Pick<PreviousFrame<T>, "postBody" | "prevState" | "pathname" | "prevRedirects">;
/**
 *
 * @param reducer a function taking a state and action and returning another action. This reducer is always called in the Frame to compute the state by calling it with the previous Frame + action
 * @param initialState the initial state to use if there was no previous action
 * @param initializerArg the previousFrame object to use to initialize the state
 * @returns An array of [State, Dispatch] where State is your reducer state, and dispatch is a function that doesn't do anything atm
 */
declare function useFramesReducer<T extends FrameState = FrameState>(reducer: FrameReducer<T>, initialState: T, initializerArg: PreviousFrame<T>): [T, Dispatch];
/**
 * A function ready made for next.js in order to directly export it, which handles all incoming `POST` requests that apps will trigger when users press buttons in your Frame.
 * It handles all the redirecting for you, correctly, based on the <FrameContainer> props defined by the Frame that triggered the user action.
 * @param req a `NextRequest` object from `next/server` (Next.js app router server components)
 * @returns NextResponse
 */
declare function POST(req: NextRequest, 
/** unused, but will most frequently be passed a res: NextResponse object. Should stay in here for easy consumption compatible with next.js */
res: NextResponse, redirectHandler?: RedirectHandler): Promise<NextResponse<unknown>>;
/**
 * A React functional component that Wraps a Frame and processes it, validating certain properties of the Frames spec, as well as adding other props. It also generates the postUrl.
 * It throws an error if the Frame is invalid, which can be caught by using an error boundary.
 * @param param0
 * @returns React.JSXElement
 */
declare function FrameContainer<T extends FrameState = FrameState>({ postUrl, children, state, pathname, previousFrame, }: {
    /** Either a relative e.g. "/frames" or an absolute path, e.g. "https://google.com/frames" */
    postUrl: string;
    /** The elements to include in the Frame */
    children: Array<React.ReactElement<FrameElementType> | null>;
    /** The current reducer state object, returned from useFramesReducer */
    state: T;
    previousFrame: PreviousFrame<T>;
    /** The absolute or relative path of the page that this frame is on, relative to root (/), defaults to (/) */
    pathname?: string;
}): React.JSX.Element;
/** Renders a 'fc:frame:button', must be used inside a <FrameContainer> */
declare function FrameButton(props: FrameButtonProvidedProps): null;
/** Render a 'fc:frame:input:text', must be used inside a <FrameContainer> */
declare function FrameInput({ text }: {
    text: string;
}): React.JSX.Element;
/** Render a 'fc:frame:image', must be used inside a <FrameContainer> */
declare function FrameImage(props: {
    /** 'fc:frame:aspect_ratio' (defaults to 1:91) */
    aspectRatio?: ImageAspectRatio;
} & ({
    src: string;
} | {
    /** Children to pass to satori to render to PNG. [Supports tailwind](https://vercel.com/blog/introducing-vercel-og-image-generation-fast-dynamic-social-card-images#tailwind-css-support) via the `tw=` prop instead of `className` */
    children: React.ReactNode;
    options?: SatoriOptions;
})): Promise<React.JSX.Element>;

export { Dispatch, FrameButton, FrameButtonProvidedProps, FrameContainer, type FrameElementType, FrameImage, FrameInput, FrameReducer, FrameState, HeadersList, NextServerPageProps, POST, PreviousFrame, RedirectHandler, createPreviousFrame, getFrameMessage, getPreviousFrame, parseFrameParams, useFramesReducer, validateActionSignature };
